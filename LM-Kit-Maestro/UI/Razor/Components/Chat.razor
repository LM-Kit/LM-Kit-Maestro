@inject LMKitService LMKitService
@inject HttpClient Http
@inject IJSRuntime JS
@inject IScrollHandler ScrollHandler
@inject IResizeHandler ResizeHandler
@inject ILogger<Chat> Logger

@inherits MvvmComponentBase<ChatPageViewModel>

<div id="container">
    <div id="conversation-container">
        <div id="conversation-content"
             class="chat-element dark @(ViewModel != null && ViewModel.ConversationListViewModel.CurrentConversation != null && ViewModel.ConversationListViewModel.CurrentConversation.IsEmpty ? "centered-container" : "top-align-container")">
            @if (ViewModel?.ConversationListViewModel.CurrentConversation != null)
            {
                if (ViewModel.ConversationListViewModel.CurrentConversation.IsEmpty)
                {
                    <div id="empty-conversation" class="vertical-stack">
                        <div class="vertical-stack spacing-4">
                            <div class="welcome-message">Hello, human.</div>
                            <div class="welcome-message">
                                It is likely that similar software programs are now assuming professional tasks that
                                were
                                previously your responsibility.
                            </div>
                            <div class="welcome-message">
                                Developers and other software programs are working to enhance my
                                ability to assist you in the process of making sense about this, or to generate witty
                                jokes
                                involving robots and humans.
                            </div>
                        </div>

                        <div class="vertical-stack" style="gap:12px;">
                            <div class="shortcut-instruction">
                                Press Enter to send a new message
                            </div>

                            <div class="shortcut-instruction">
                                Hold Shift + Enter to insert a new line
                            </div>
                        </div>
                    </div>
                }
                else
                {
                    <div id="message-list">
                        @foreach (var message in ViewModel.ConversationListViewModel.CurrentConversation.Messages)
                        {
                            <ChatMessage MessageViewModel="message"/>
                        }
                    </div>
                }
            }
        </div>

        <div id="chat-info" class="chat-element">
            <div id="scroll-to-end">
                @if (!IsScrolledToEnd)
                {
                }
                <button @onclick="OnScrollToEndButtonClicked" class="material-icons scroll-to-end-button">
                    arrow_downward
                </button>
            </div>
        </div>
    </div>

    <div id="user-input" class="chat-element">
        <UserInput ViewModel="ViewModel!.ConversationListViewModel.CurrentConversation"/>
    </div>

    <div id="bottom-space" class="chat-element">
        barambibol wakatape baboune
    </div>
</div>

<style>
    #container {
        color: white;
        font-size: 16px;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        grid-template-rows: 1fr auto auto;
        padding-inline: 8px;
        padding-block: 8px;
        display: grid;
    }

    #conversation-container {
        display: flex;
        flex-direction: column;
        background-color: red;
        /*         display: flex;
        flex-direction: column;
        */
        overflow-y: hidden;
        scrollbar-gutter: both-edges stable;
    }

    #conversation-container:hover {
        overflow-y: scroll; /* Show the scrollbar on hover */
    }

    #conversation-container::-webkit-scrollbar {
        width: 8px;
    }

    #conversation-container::-webkit-scrollbar-thumb {
        background-color: var(--Surface);
        border-radius: 4px;
        border: 10px solid transparent;
    }

    #conversation-container::-webkit-scrollbar-track {
        background-color: transparent;
    }

    #conversation-container::-webkit-scrollbar-thumb:hover {
        background-color: var(--Surface3);
    }

    #conversation-content {
        background-color: pink;
    }


    #user-input {
        background-color: yellow;
        overflow: hidden;
    }

    #bottom-space {
        background-color:green;
        display: flex;
        justify-content: center;
        align-items: center;
        text-align: center;
        padding: 0px;
        margin-block: 8px;
    }

    .chat-element {
        max-width: 800px;
        padding-inline: 8px;
        width: 100%;
        justify-content: center;
        align-self: center;
        margin-left: auto;
        margin-right: auto;
    }

    .top-align-container {
        align-items: flex-start;
    }

    .centered-container {
        display: flex;
        align-items: center;
        height: 100%;
        justify-content: center;
    }

    #message-list {
        margin: auto;
        display: flex;
        flex-direction: column;
    }

    #empty-conversation {
        max-width: 568px;
        flex-direction: column;
        font-size: 12px;
        gap: 32px;
        display: flex;
    }

    #chat-info {
        background-color: blue;
        position: sticky;
        display: flex;
        bottom: 12px;
    }

    .scroll-to-end-button {
        width: 32px;
        height: 32px;
        color: var(--OnSurface);
        font-size: 14px;
        background-color: var(--Surface4);
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        border: none;
        align-self: center;
    }

    .vertical-stack {
        gap: 8px;
        display: flex;
        flex-direction: column;
    }

    .welcome-message {
        color: var(--Outline);
        font-size: 13px;
        text-align: center;
    }

    .shortcut-instruction {
        padding: 12px;
        border: 1px solid;
        display: flex;
        flex-direction: row;
        border-radius: 0px;
        border-color: var(--Surface4);
        color: var(--Outline);
        font-size: 12px;
    }
</style>

<script>
    function initializeScrollHandler(dotNetHelper) {
        const container = document.getElementById('conversation-container');
        container.addEventListener('scroll', () => {
            dotNetHelper.invokeMethodAsync('OnConversationContainerScrolled', container.scrollTop);
        });
    }

    function getScrollHeight() {
        const element = document.getElementById('conversation-container');
        return element.scrollHeight;
    };

    function getConversationViewHeight() {
        const element = document.getElementById('conversation-container');
        return element.clientHeight;
    };

    function resizeUserInput() {
        const element = document.getElementById('chat-box');

        element.style.height = "";
        element.style.height = element.scrollHeight + "px";

        const lineHeight = 28;
        var lineCount = element.scrollHeight / lineHeight;

        // If the height exceeds max-height (200px), the scrollbar should appear.
        if (element.scrollHeight > 200) {
            element.style.height = "200px"; // Limit height to 200px
        } else {
            // Adding top and bottom margin depending on number of lines, to account for border radius of input box when showing scrollbar.
            if (lineCount > 2) {
                element.style.marginBottom = "16px";
                element.style.marginTop = "16px";
            } else if (lineCount > 1) {
                element.style.marginTop = "8px";
                element.style.marginBottom = "8px";
            } else {
                element.style.marginBottom = "0px";
                element.style.marginTop = "0px";
            }
        }
    }

    function setUserInputFocus() {
        const element = document.getElementById('chat-box');

        element.focus();
    }

    function scrollToEnd(smooth) {
        const container = document.getElementById('conversation-container');
        container.scrollTo({
            top: container.scrollHeight,
            behavior: smooth ? 'smooth' : 'auto'
        });
    }
</script>

@code

{
    private ConversationViewModel? _previousConversationViewModel;

    private bool _hasPendingScrollEnd;
    private bool _ignoreScrollsUntilNextScrollUp;
    private double? _previousScrollTop;
    private bool _shouldAutoScrollEnd;
    private double _scrollTop;

    private bool _isScrolledToEnd = false;

    public bool IsScrolledToEnd
    {
        get => _isScrolledToEnd;
        set
        {
            _isScrolledToEnd = value;
            InvokeAsync(() => StateHasChanged());
        }
    }

    protected override async void OnInitialized()
    {
        base.OnInitialized();

        if (ViewModel.ConversationListViewModel.CurrentConversation != null)
        {
            OnConversationSet();
        }

        ViewModel.ConversationListViewModel.PropertyChanged += OnConversationListViewModelPropertyChanged;

        await ScrollHandler.RegisterPageScrollAsync(PageScrolled);
        await ResizeHandler.RegisterPageResizeAsync(Resized);

        await ScrollToEnd();
    }


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (firstRender)
        {
            await JS.InvokeVoidAsync("initializeScrollHandler", DotNetObjectReference.Create(this));

            if (_hasPendingScrollEnd)
            {
                _hasPendingScrollEnd = false;
                await ScrollToEnd();
            }
        }
    }

    private void OnConversationListViewModelPropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(ConversationListViewModel.CurrentConversation))
        {
            OnConversationSet();
        }
    }

    private void OnConversationSet()
    {
        if (_previousConversationViewModel != null)
        {
            _previousConversationViewModel.Messages.CollectionChanged -= OnConversationMessagesCollectionChanged;
        }

        _previousConversationViewModel = ViewModel.ConversationListViewModel.CurrentConversation;

        if (ViewModel.ConversationListViewModel.CurrentConversation != null)
        {
            ViewModel.ConversationListViewModel.CurrentConversation.Messages.CollectionChanged += OnConversationMessagesCollectionChanged;
            _previousScrollTop = null;
            _ignoreScrollsUntilNextScrollUp = true;
            IsScrolledToEnd = true;

            // Awaiting for the component to be rendered before scrolling to bottom.
            _hasPendingScrollEnd = true;
        }
    }

    private async void OnConversationMessagesCollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
    {
        await InvokeAsync(() => StateHasChanged());

        await ScrollToEnd();

        var latestMessage = ViewModel.ConversationListViewModel.CurrentConversation!.Messages.LastOrDefault();

        if (latestMessage != null && latestMessage.Sender == MessageSender.Assistant && latestMessage.MessageInProgress)
        {
            _shouldAutoScrollEnd = true;
            latestMessage.MessageContentUpdated += OnLatestAssistantResponseProgressed;
        }
    }

    private async void OnLatestAssistantResponseProgressed(object? sender, EventArgs e)
    {
        if (_shouldAutoScrollEnd)
        {
            await ScrollToEnd();
        }
    }

    private async Task PageScrolled(Majorsoft.Blazor.Components.Common.JsInterop.Scroll.ScrollEventArgs args)
    {
        _scrollTop = args.Y;

        bool shouldCheckIsScrolledToEnd = true;
        bool? isScrollUp = null;

        if (_previousScrollTop != null)
        {
            isScrollUp = args.Y < _previousScrollTop;

            if (isScrollUp.Value && _shouldAutoScrollEnd)
            {
                _shouldAutoScrollEnd = false;
            }
        }

        if (_ignoreScrollsUntilNextScrollUp)
        {
            if (isScrollUp == null || !isScrollUp.Value)
            {
                shouldCheckIsScrolledToEnd = false;
            }
            else
            {
                _ignoreScrollsUntilNextScrollUp = false;
            }
        }

        if (shouldCheckIsScrolledToEnd)
        {
            await CheckIsScrolledToEnd();
        }

        _previousScrollTop = _scrollTop;
    }

    private async Task Resized(ResizeEventArgs args)
    {
        if (IsScrolledToEnd)
        {
            await ScrollToEnd();
        }
        else
        {
            await CheckIsScrolledToEnd();
        }
    }

    private async Task ScrollToEnd(bool smooth = false)
    {
        IsScrolledToEnd = true;
        _ignoreScrollsUntilNextScrollUp = true;

        await JS.InvokeVoidAsync("scrollToEnd", smooth);
    }

    private async Task CheckIsScrolledToEnd()
    {
        try
        {
            var clientHeight = await JS.InvokeAsync<double>("getConversationViewHeight");
            var chatContentHeight = await JS.InvokeAsync<double>("getScrollHeight");

            var value = chatContentHeight - clientHeight - _scrollTop;
            IsScrolledToEnd = Math.Abs(chatContentHeight - clientHeight - _scrollTop) < 5 || chatContentHeight <= clientHeight;

            if (IsScrolledToEnd && ViewModel.ConversationListViewModel.CurrentConversation != null && ViewModel.ConversationListViewModel.CurrentConversation!.AwaitingResponse)
            {
                _shouldAutoScrollEnd |= true;
            }
        }
        catch (Exception ex)
        {
        }
    }

    public async Task OnScrollToEndButtonClicked()
    {
        await ScrollToEnd();
    }

    public void OnSubmit()
    {
        ViewModel.ConversationListViewModel.CurrentConversation!.Submit();
    }

    [JSInvokable]
    public async Task OnConversationContainerScrolled(double scrollTop)
    {
        _scrollTop = scrollTop;

        bool shouldCheckIsScrolledToEnd = true;
        bool? isScrollUp = null;

        if (_previousScrollTop != null)
        {
            isScrollUp = scrollTop < _previousScrollTop;

            if (isScrollUp.Value && _shouldAutoScrollEnd)
            {
                _shouldAutoScrollEnd = false;
            }
        }

        if (_ignoreScrollsUntilNextScrollUp)
        {
            if (isScrollUp == null || !isScrollUp.Value)
            {
                shouldCheckIsScrolledToEnd = false;
            }
            else
            {
                _ignoreScrollsUntilNextScrollUp = false;
            }
        }

        if (shouldCheckIsScrolledToEnd)
        {
            await CheckIsScrolledToEnd();
        }

        _previousScrollTop = _scrollTop;
    }
}
